{
  "uid" : "f744f579bd2f8262",
  "name" : "test_loginByCaptcha",
  "fullName" : "test_002_loginByCaptcha.Test_loginByCaptcha#test_loginByCaptcha",
  "historyId" : "2c4c0ff60efde21ca19a24ee615ea1aa",
  "time" : {
    "start" : 1606896150498,
    "stop" : 1606896187473,
    "duration" : 36975
  },
  "status" : "broken",
  "statusMessage" : "sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, \"Can't connect to MySQL server on 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com' ([Errno 11001] getaddrinfo failed)\")\n(Background on this error at: http://sqlalche.me/e/13/e3q8)",
  "statusTrace" : "self = <pymysql.connections.Connection object at 0x000002C126CFE340>\nsock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n>                           sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:569: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', 3306), timeout = 10\nsource_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n>       for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n\nc:\\python38\\lib\\socket.py:787: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhost = 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', port = 3306, family = 0\ntype = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0\n\n    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):\n        \"\"\"Resolve host and port into list of address info entries.\n    \n        Translate the host/port argument into a sequence of 5-tuples that contain\n        all the necessary arguments for creating a socket connected to that service.\n        host is a domain name, a string representation of an IPv4/v6 address or\n        None. port is a string service name such as 'http', a numeric port number or\n        None. By passing None as the value of host and port, you can pass NULL to\n        the underlying C API.\n    \n        The family, type and proto arguments can be optionally specified in order to\n        narrow the list of addresses returned. Passing zero as a value for each of\n        these arguments selects the full range of results.\n        \"\"\"\n        # We override this function since we want to translate the numeric family\n        # and socket type values to enum constants.\n        addrlist = []\n>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\nE       socket.gaierror: [Errno 11001] getaddrinfo failed\n\nc:\\python38\\lib\\socket.py:918: gaierror\n\nDuring handling of the above exception, another exception occurred:\n\nself = Engine(mysql+pymysql://timing_read_only:***@rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com:3306/timing?charset=utf8)\nfn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>>\nconnection = None\n\n    def _wrap_pool_connect(self, fn, connection):\n        dialect = self.dialect\n        try:\n>           return fn()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2339: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def connect(self):\n        \"\"\"Return a DBAPI connection from the pool.\n    \n        The connection is instrumented such that when its\n        ``close()`` method is called, the connection will be returned to\n        the pool.\n    \n        \"\"\"\n        if not self._use_threadlocal:\n>           return _ConnectionFairy._checkout(self)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:364: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <class 'sqlalchemy.pool.base._ConnectionFairy'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\nthreadconns = None, fairy = None\n\n    @classmethod\n    def _checkout(cls, pool, threadconns=None, fairy=None):\n        if not fairy:\n>           fairy = _ConnectionRecord.checkout(pool)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:778: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <class 'sqlalchemy.pool.base._ConnectionRecord'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    @classmethod\n    def checkout(cls, pool):\n>       rec = pool._do_get()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:495: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %d\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n                return self._create_connection()\n            except:\n                with util.safe_reraise():\n>                   self._dec_overflow()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:140: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.util.langhelpers.safe_reraise object at 0x000002C126CFE430>\ntype_ = None, value = None, traceback = None\n\n    def __exit__(self, type_, value, traceback):\n        # see #2703 for notes\n        if type_ is None:\n            exc_type, exc_value, exc_tb = self._exc_info\n            self._exc_info = None  # remove potential circular references\n            if not self.warn_only:\n>               compat.raise_(\n                    exc_value, with_traceback=exc_tb,\n                )\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def raise_(\n        exception, with_traceback=None, replace_context=None, from_=False\n    ):\n        r\"\"\"implement \"raise\" with cause support.\n    \n        :param exception: exception to raise\n        :param with_traceback: will call exception.with_traceback()\n        :param replace_context: an as-yet-unsupported feature.  This is\n         an exception object which we are \"replacing\", e.g., it's our\n         \"cause\" but we don't want it printed.    Basically just what\n         ``__suppress_context__`` does but we don't want to suppress\n         the enclosing context, if any.  So for now we make it the\n         cause.\n        :param from\\_: the cause.  this actually sets the cause and doesn't\n         hope to hide it someday.\n    \n        \"\"\"\n        if with_traceback is not None:\n            exception = exception.with_traceback(with_traceback)\n    \n        if from_ is not False:\n            exception.__cause__ = from_\n        elif replace_context is not None:\n            # no good solution here, we would like to have the exception\n            # have only the context of replace_context.__context__ so that the\n            # intermediary exception does not change, but we can't figure\n            # that out.\n            exception.__cause__ = replace_context\n    \n        try:\n>           raise exception\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %d\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n>               return self._create_connection()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:137: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def _create_connection(self):\n        \"\"\"Called by subclasses to create a new ConnectionRecord.\"\"\"\n    \n>       return _ConnectionRecord(self)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\nconnect = True\n\n    def __init__(self, pool, connect=True):\n        self.__pool = pool\n        if connect:\n>           self.__connect(first_connect_check=True)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:440: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\nfirst_connect_check = True\n\n    def __connect(self, first_connect_check=False):\n        pool = self.__pool\n    \n        # ensure any existing connection is removed, so that if\n        # creator fails, this attribute stays None\n        self.connection = None\n        try:\n            self.starttime = time.time()\n            connection = pool._invoke_creator(self)\n            pool.logger.debug(\"Created new connection %r\", connection)\n            self.connection = connection\n        except Exception as e:\n            with util.safe_reraise():\n>               pool.logger.debug(\"Error on connect(): %s\", e)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:661: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.util.langhelpers.safe_reraise object at 0x000002C126CFE400>\ntype_ = None, value = None, traceback = None\n\n    def __exit__(self, type_, value, traceback):\n        # see #2703 for notes\n        if type_ is None:\n            exc_type, exc_value, exc_tb = self._exc_info\n            self._exc_info = None  # remove potential circular references\n            if not self.warn_only:\n>               compat.raise_(\n                    exc_value, with_traceback=exc_tb,\n                )\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def raise_(\n        exception, with_traceback=None, replace_context=None, from_=False\n    ):\n        r\"\"\"implement \"raise\" with cause support.\n    \n        :param exception: exception to raise\n        :param with_traceback: will call exception.with_traceback()\n        :param replace_context: an as-yet-unsupported feature.  This is\n         an exception object which we are \"replacing\", e.g., it's our\n         \"cause\" but we don't want it printed.    Basically just what\n         ``__suppress_context__`` does but we don't want to suppress\n         the enclosing context, if any.  So for now we make it the\n         cause.\n        :param from\\_: the cause.  this actually sets the cause and doesn't\n         hope to hide it someday.\n    \n        \"\"\"\n        if with_traceback is not None:\n            exception = exception.with_traceback(with_traceback)\n    \n        if from_ is not False:\n            exception.__cause__ = from_\n        elif replace_context is not None:\n            # no good solution here, we would like to have the exception\n            # have only the context of replace_context.__context__ so that the\n            # intermediary exception does not change, but we can't figure\n            # that out.\n            exception.__cause__ = replace_context\n    \n        try:\n>           raise exception\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\nfirst_connect_check = True\n\n    def __connect(self, first_connect_check=False):\n        pool = self.__pool\n    \n        # ensure any existing connection is removed, so that if\n        # creator fails, this attribute stays None\n        self.connection = None\n        try:\n            self.starttime = time.time()\n>           connection = pool._invoke_creator(self)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:656: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconnection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\n\n    def connect(connection_record=None):\n        if dialect._has_events:\n            for fn in dialect.dispatch.do_connect:\n                connection = fn(\n                    dialect, connection_record, cargs, cparams\n                )\n                if connection is not None:\n                    return connection\n>       return dialect.connect(*cargs, **cparams)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\strategies.py:114: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x000002C1267B4910>\ncargs = ()\ncparams = {'charset': 'utf8', 'client_flag': 2, 'db': 'timing', 'host': 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', ...}\n\n    def connect(self, *cargs, **cparams):\n        # inherits the docstring from interfaces.Dialect.connect\n>       return self.dbapi.connect(*cargs, **cparams)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\default.py:493: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nargs = ()\nkwargs = {'charset': 'utf8', 'client_flag': 2, 'db': 'timing', 'host': 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', ...}\nConnection = <class 'pymysql.connections.Connection'>\n\n    def Connect(*args, **kwargs):\n        \"\"\"\n        Connect to the database; see connections.Connection.__init__() for\n        more information.\n        \"\"\"\n        from .connections import Connection\n>       return Connection(*args, **kwargs)\n\nc:\\python38\\lib\\site-packages\\pymysql\\__init__.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000002C126CFE340>\nhost = 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com'\nuser = 'timing_read_only', password = 'db_only_hsyt21', database = 'timing'\nport = 3306, unix_socket = None, charset = 'utf8', sql_mode = None\nread_default_file = None\nconv = {<class 'bool'>: <function escape_bool at 0x000002C126BFA280>, <class 'int'>: <function escape_int at 0x000002C126BFA3...'>: <function escape_float at 0x000002C126BFA430>, <class 'str'>: <function escape_unicode at 0x000002C126BFA670>, ...}\nuse_unicode = True, client_flag = 3842575\ncursorclass = <class 'pymysql.cursors.Cursor'>, init_command = None\nconnect_timeout = 10, ssl = None, read_default_group = None, compress = None\nnamed_pipe = None, autocommit = False, db = 'timing', passwd = 'db_only_hsyt21'\nlocal_infile = False, max_allowed_packet = 16777216, defer_connect = False\nauth_plugin_map = None, read_timeout = None, write_timeout = None\nbind_address = None, binary_prefix = False, program_name = None\nserver_public_key = None\n\n    def __init__(self, host=None, user=None, password=\"\",\n                 database=None, port=0, unix_socket=None,\n                 charset='', sql_mode=None,\n                 read_default_file=None, conv=None, use_unicode=None,\n                 client_flag=0, cursorclass=Cursor, init_command=None,\n                 connect_timeout=10, ssl=None, read_default_group=None,\n                 compress=None, named_pipe=None,\n                 autocommit=False, db=None, passwd=None, local_infile=False,\n                 max_allowed_packet=16*1024*1024, defer_connect=False,\n                 auth_plugin_map=None, read_timeout=None, write_timeout=None,\n                 bind_address=None, binary_prefix=False, program_name=None,\n                 server_public_key=None):\n        if use_unicode is None and sys.version_info[0] > 2:\n            use_unicode = True\n    \n        if db is not None and database is None:\n            database = db\n        if passwd is not None and not password:\n            password = passwd\n    \n        if compress or named_pipe:\n            raise NotImplementedError(\"compress and named_pipe arguments are not supported\")\n    \n        self._local_infile = bool(local_infile)\n        if self._local_infile:\n            client_flag |= CLIENT.LOCAL_FILES\n    \n        if read_default_group and not read_default_file:\n            if sys.platform.startswith(\"win\"):\n                read_default_file = \"c:\\\\my.ini\"\n            else:\n                read_default_file = \"/etc/my.cnf\"\n    \n        if read_default_file:\n            if not read_default_group:\n                read_default_group = \"client\"\n    \n            cfg = Parser()\n            cfg.read(os.path.expanduser(read_default_file))\n    \n            def _config(key, arg):\n                if arg:\n                    return arg\n                try:\n                    return cfg.get(read_default_group, key)\n                except Exception:\n                    return arg\n    \n            user = _config(\"user\", user)\n            password = _config(\"password\", password)\n            host = _config(\"host\", host)\n            database = _config(\"database\", database)\n            unix_socket = _config(\"socket\", unix_socket)\n            port = int(_config(\"port\", port))\n            bind_address = _config(\"bind-address\", bind_address)\n            charset = _config(\"default-character-set\", charset)\n            if not ssl:\n                ssl = {}\n            if isinstance(ssl, dict):\n                for key in [\"ca\", \"capath\", \"cert\", \"key\", \"cipher\"]:\n                    value = _config(\"ssl-\" + key, ssl.get(key))\n                    if value:\n                        ssl[key] = value\n    \n        self.ssl = False\n        if ssl:\n            if not SSL_ENABLED:\n                raise NotImplementedError(\"ssl module not found\")\n            self.ssl = True\n            client_flag |= CLIENT.SSL\n            self.ctx = self._create_ssl_ctx(ssl)\n    \n        self.host = host or \"localhost\"\n        self.port = port or 3306\n        if type(self.port) is not int:\n            raise ValueError(\"port should be of type int\")\n        self.user = user or DEFAULT_USER\n        self.password = password or b\"\"\n        if isinstance(self.password, text_type):\n            self.password = self.password.encode('latin1')\n        self.db = database\n        self.unix_socket = unix_socket\n        self.bind_address = bind_address\n        if not (0 < connect_timeout <= 31536000):\n            raise ValueError(\"connect_timeout should be >0 and <=31536000\")\n        self.connect_timeout = connect_timeout or None\n        if read_timeout is not None and read_timeout <= 0:\n            raise ValueError(\"read_timeout should be > 0\")\n        self._read_timeout = read_timeout\n        if write_timeout is not None and write_timeout <= 0:\n            raise ValueError(\"write_timeout should be > 0\")\n        self._write_timeout = write_timeout\n        if charset:\n            self.charset = charset\n            self.use_unicode = True\n        else:\n            self.charset = DEFAULT_CHARSET\n            self.use_unicode = False\n    \n        if use_unicode is not None:\n            self.use_unicode = use_unicode\n    \n        self.encoding = charset_by_name(self.charset).encoding\n    \n        client_flag |= CLIENT.CAPABILITIES\n        if self.db:\n            client_flag |= CLIENT.CONNECT_WITH_DB\n    \n        self.client_flag = client_flag\n    \n        self.cursorclass = cursorclass\n    \n        self._result = None\n        self._affected_rows = 0\n        self.host_info = \"Not connected\"\n    \n        # specified autocommit mode. None means use server default.\n        self.autocommit_mode = autocommit\n    \n        if conv is None:\n            conv = converters.conversions\n    \n        # Need for MySQLdb compatibility.\n        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}\n        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}\n        self.sql_mode = sql_mode\n        self.init_command = init_command\n        self.max_allowed_packet = max_allowed_packet\n        self._auth_plugin_map = auth_plugin_map or {}\n        self._binary_prefix = binary_prefix\n        self.server_public_key = server_public_key\n    \n        self._connect_attrs = {\n            '_client_name': 'pymysql',\n            '_pid': str(os.getpid()),\n            '_client_version': VERSION_STRING,\n        }\n    \n        if program_name:\n            self._connect_attrs[\"program_name\"] = program_name\n    \n        if defer_connect:\n            self._sock = None\n        else:\n>           self.connect()\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000002C126CFE340>\nsock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG: print('connected using socket')\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                sock.settimeout(None)\n    \n            self._sock = sock\n            self._rfile = _makefile(sock, 'rb')\n            self._next_seq_id = 0\n    \n            self._get_server_information()\n            self._request_authentication()\n    \n            if self.sql_mode is not None:\n                c = self.cursor()\n                c.execute(\"SET sql_mode=%s\", (self.sql_mode,))\n    \n            if self.init_command is not None:\n                c = self.cursor()\n                c.execute(self.init_command)\n                c.close()\n                self.commit()\n    \n            if self.autocommit_mode is not None:\n                self.autocommit(self.autocommit_mode)\n        except BaseException as e:\n            self._rfile = None\n            if sock is not None:\n                try:\n                    sock.close()\n                except:  # noqa\n                    pass\n    \n            if isinstance(e, (OSError, IOError, socket.error)):\n                exc = err.OperationalError(\n                        2003,\n                        \"Can't connect to MySQL server on %r (%s)\" % (\n                            self.host, e))\n                # Keep original exception and traceback to investigate error.\n                exc.original_exception = e\n                exc.traceback = traceback.format_exc()\n                if DEBUG: print(exc.traceback)\n>               raise exc\nE               pymysql.err.OperationalError: (2003, \"Can't connect to MySQL server on 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com' ([Errno 11001] getaddrinfo failed)\")\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:619: OperationalError\n\nThe above exception was the direct cause of the following exception:\n\nself = <scripts.test_002_loginByCaptcha.Test_loginByCaptcha object at 0x000002C11AAB9C40>\n\n    def test_loginByCaptcha(self):\n        with allure.step('点击手机号登录'):\n            self.page.login().click_phone_login()\n        with allure.step('输入手机号'):\n            self.page.login_phone().input_phone(str(phone))\n        with allure.step('点击获取验证码按钮'):\n            self.page.login_phone().click_getCaptcha()\n            time.sleep(2)\n        with allure.step('正式服数据库拿验证码'):\n>           captcha = pd.read_sql('select captcha FROM t_captcha WHERE phone = \"' + str(phone) + '\" order by postTime desc',engine)\n\ntest_002_loginByCaptcha.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nc:\\python38\\lib\\site-packages\\pandas\\io\\sql.py:509: in read_sql\n    return pandas_sql.read_query(\nc:\\python38\\lib\\site-packages\\pandas\\io\\sql.py:1295: in read_query\n    result = self.execute(*args)\nc:\\python38\\lib\\site-packages\\pandas\\io\\sql.py:1161: in execute\n    return self.connectable.execution_options(no_parameters=True).execute(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2237: in execute\n    connection = self._contextual_connect(close_with_result=True)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2305: in _contextual_connect\n    self._wrap_pool_connect(self.pool.connect, None),\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2342: in _wrap_pool_connect\n    Connection._handle_dbapi_exception_noconnection(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:1584: in _handle_dbapi_exception_noconnection\n    util.raise_(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: in raise_\n    raise exception\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2339: in _wrap_pool_connect\n    return fn()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:364: in connect\n    return _ConnectionFairy._checkout(self)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:778: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:495: in checkout\n    rec = pool._do_get()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:140: in _do_get\n    self._dec_overflow()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: in __exit__\n    compat.raise_(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: in raise_\n    raise exception\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:137: in _do_get\n    return self._create_connection()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:309: in _create_connection\n    return _ConnectionRecord(self)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:440: in __init__\n    self.__connect(first_connect_check=True)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:661: in __connect\n    pool.logger.debug(\"Error on connect(): %s\", e)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: in __exit__\n    compat.raise_(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: in raise_\n    raise exception\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:656: in __connect\n    connection = pool._invoke_creator(self)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\strategies.py:114: in connect\n    return dialect.connect(*cargs, **cparams)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\default.py:493: in connect\n    return self.dbapi.connect(*cargs, **cparams)\nc:\\python38\\lib\\site-packages\\pymysql\\__init__.py:94: in Connect\n    return Connection(*args, **kwargs)\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:327: in __init__\n    self.connect()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000002C126CFE340>\nsock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG: print('connected using socket')\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                sock.settimeout(None)\n    \n            self._sock = sock\n            self._rfile = _makefile(sock, 'rb')\n            self._next_seq_id = 0\n    \n            self._get_server_information()\n            self._request_authentication()\n    \n            if self.sql_mode is not None:\n                c = self.cursor()\n                c.execute(\"SET sql_mode=%s\", (self.sql_mode,))\n    \n            if self.init_command is not None:\n                c = self.cursor()\n                c.execute(self.init_command)\n                c.close()\n                self.commit()\n    \n            if self.autocommit_mode is not None:\n                self.autocommit(self.autocommit_mode)\n        except BaseException as e:\n            self._rfile = None\n            if sock is not None:\n                try:\n                    sock.close()\n                except:  # noqa\n                    pass\n    \n            if isinstance(e, (OSError, IOError, socket.error)):\n                exc = err.OperationalError(\n                        2003,\n                        \"Can't connect to MySQL server on %r (%s)\" % (\n                            self.host, e))\n                # Keep original exception and traceback to investigate error.\n                exc.original_exception = e\n                exc.traceback = traceback.format_exc()\n                if DEBUG: print(exc.traceback)\n>               raise exc\nE               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, \"Can't connect to MySQL server on 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com' ([Errno 11001] getaddrinfo failed)\")\nE               (Background on this error at: http://sqlalche.me/e/13/e3q8)\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:619: OperationalError",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ ],
  "testStage" : {
    "status" : "broken",
    "statusMessage" : "sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, \"Can't connect to MySQL server on 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com' ([Errno 11001] getaddrinfo failed)\")\n(Background on this error at: http://sqlalche.me/e/13/e3q8)",
    "statusTrace" : "self = <pymysql.connections.Connection object at 0x000002C126CFE340>\nsock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n>                           sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:569: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', 3306), timeout = 10\nsource_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n>       for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n\nc:\\python38\\lib\\socket.py:787: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nhost = 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', port = 3306, family = 0\ntype = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0\n\n    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):\n        \"\"\"Resolve host and port into list of address info entries.\n    \n        Translate the host/port argument into a sequence of 5-tuples that contain\n        all the necessary arguments for creating a socket connected to that service.\n        host is a domain name, a string representation of an IPv4/v6 address or\n        None. port is a string service name such as 'http', a numeric port number or\n        None. By passing None as the value of host and port, you can pass NULL to\n        the underlying C API.\n    \n        The family, type and proto arguments can be optionally specified in order to\n        narrow the list of addresses returned. Passing zero as a value for each of\n        these arguments selects the full range of results.\n        \"\"\"\n        # We override this function since we want to translate the numeric family\n        # and socket type values to enum constants.\n        addrlist = []\n>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\nE       socket.gaierror: [Errno 11001] getaddrinfo failed\n\nc:\\python38\\lib\\socket.py:918: gaierror\n\nDuring handling of the above exception, another exception occurred:\n\nself = Engine(mysql+pymysql://timing_read_only:***@rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com:3306/timing?charset=utf8)\nfn = <bound method Pool.connect of <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>>\nconnection = None\n\n    def _wrap_pool_connect(self, fn, connection):\n        dialect = self.dialect\n        try:\n>           return fn()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2339: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def connect(self):\n        \"\"\"Return a DBAPI connection from the pool.\n    \n        The connection is instrumented such that when its\n        ``close()`` method is called, the connection will be returned to\n        the pool.\n    \n        \"\"\"\n        if not self._use_threadlocal:\n>           return _ConnectionFairy._checkout(self)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:364: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <class 'sqlalchemy.pool.base._ConnectionFairy'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\nthreadconns = None, fairy = None\n\n    @classmethod\n    def _checkout(cls, pool, threadconns=None, fairy=None):\n        if not fairy:\n>           fairy = _ConnectionRecord.checkout(pool)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:778: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ncls = <class 'sqlalchemy.pool.base._ConnectionRecord'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    @classmethod\n    def checkout(cls, pool):\n>       rec = pool._do_get()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:495: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %d\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n                return self._create_connection()\n            except:\n                with util.safe_reraise():\n>                   self._dec_overflow()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:140: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.util.langhelpers.safe_reraise object at 0x000002C126CFE430>\ntype_ = None, value = None, traceback = None\n\n    def __exit__(self, type_, value, traceback):\n        # see #2703 for notes\n        if type_ is None:\n            exc_type, exc_value, exc_tb = self._exc_info\n            self._exc_info = None  # remove potential circular references\n            if not self.warn_only:\n>               compat.raise_(\n                    exc_value, with_traceback=exc_tb,\n                )\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def raise_(\n        exception, with_traceback=None, replace_context=None, from_=False\n    ):\n        r\"\"\"implement \"raise\" with cause support.\n    \n        :param exception: exception to raise\n        :param with_traceback: will call exception.with_traceback()\n        :param replace_context: an as-yet-unsupported feature.  This is\n         an exception object which we are \"replacing\", e.g., it's our\n         \"cause\" but we don't want it printed.    Basically just what\n         ``__suppress_context__`` does but we don't want to suppress\n         the enclosing context, if any.  So for now we make it the\n         cause.\n        :param from\\_: the cause.  this actually sets the cause and doesn't\n         hope to hide it someday.\n    \n        \"\"\"\n        if with_traceback is not None:\n            exception = exception.with_traceback(with_traceback)\n    \n        if from_ is not False:\n            exception.__cause__ = from_\n        elif replace_context is not None:\n            # no good solution here, we would like to have the exception\n            # have only the context of replace_context.__context__ so that the\n            # intermediary exception does not change, but we can't figure\n            # that out.\n            exception.__cause__ = replace_context\n    \n        try:\n>           raise exception\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %d\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n>               return self._create_connection()\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:137: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\n\n    def _create_connection(self):\n        \"\"\"Called by subclasses to create a new ConnectionRecord.\"\"\"\n    \n>       return _ConnectionRecord(self)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x000002C126BFB700>\nconnect = True\n\n    def __init__(self, pool, connect=True):\n        self.__pool = pool\n        if connect:\n>           self.__connect(first_connect_check=True)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:440: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\nfirst_connect_check = True\n\n    def __connect(self, first_connect_check=False):\n        pool = self.__pool\n    \n        # ensure any existing connection is removed, so that if\n        # creator fails, this attribute stays None\n        self.connection = None\n        try:\n            self.starttime = time.time()\n            connection = pool._invoke_creator(self)\n            pool.logger.debug(\"Created new connection %r\", connection)\n            self.connection = connection\n        except Exception as e:\n            with util.safe_reraise():\n>               pool.logger.debug(\"Error on connect(): %s\", e)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:661: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.util.langhelpers.safe_reraise object at 0x000002C126CFE400>\ntype_ = None, value = None, traceback = None\n\n    def __exit__(self, type_, value, traceback):\n        # see #2703 for notes\n        if type_ is None:\n            exc_type, exc_value, exc_tb = self._exc_info\n            self._exc_info = None  # remove potential circular references\n            if not self.warn_only:\n>               compat.raise_(\n                    exc_value, with_traceback=exc_tb,\n                )\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def raise_(\n        exception, with_traceback=None, replace_context=None, from_=False\n    ):\n        r\"\"\"implement \"raise\" with cause support.\n    \n        :param exception: exception to raise\n        :param with_traceback: will call exception.with_traceback()\n        :param replace_context: an as-yet-unsupported feature.  This is\n         an exception object which we are \"replacing\", e.g., it's our\n         \"cause\" but we don't want it printed.    Basically just what\n         ``__suppress_context__`` does but we don't want to suppress\n         the enclosing context, if any.  So for now we make it the\n         cause.\n        :param from\\_: the cause.  this actually sets the cause and doesn't\n         hope to hide it someday.\n    \n        \"\"\"\n        if with_traceback is not None:\n            exception = exception.with_traceback(with_traceback)\n    \n        if from_ is not False:\n            exception.__cause__ = from_\n        elif replace_context is not None:\n            # no good solution here, we would like to have the exception\n            # have only the context of replace_context.__context__ so that the\n            # intermediary exception does not change, but we can't figure\n            # that out.\n            exception.__cause__ = replace_context\n    \n        try:\n>           raise exception\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\nfirst_connect_check = True\n\n    def __connect(self, first_connect_check=False):\n        pool = self.__pool\n    \n        # ensure any existing connection is removed, so that if\n        # creator fails, this attribute stays None\n        self.connection = None\n        try:\n            self.starttime = time.time()\n>           connection = pool._invoke_creator(self)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:656: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nconnection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x000002C126CFE2E0>\n\n    def connect(connection_record=None):\n        if dialect._has_events:\n            for fn in dialect.dispatch.do_connect:\n                connection = fn(\n                    dialect, connection_record, cargs, cparams\n                )\n                if connection is not None:\n                    return connection\n>       return dialect.connect(*cargs, **cparams)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\strategies.py:114: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x000002C1267B4910>\ncargs = ()\ncparams = {'charset': 'utf8', 'client_flag': 2, 'db': 'timing', 'host': 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', ...}\n\n    def connect(self, *cargs, **cparams):\n        # inherits the docstring from interfaces.Dialect.connect\n>       return self.dbapi.connect(*cargs, **cparams)\n\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\default.py:493: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nargs = ()\nkwargs = {'charset': 'utf8', 'client_flag': 2, 'db': 'timing', 'host': 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com', ...}\nConnection = <class 'pymysql.connections.Connection'>\n\n    def Connect(*args, **kwargs):\n        \"\"\"\n        Connect to the database; see connections.Connection.__init__() for\n        more information.\n        \"\"\"\n        from .connections import Connection\n>       return Connection(*args, **kwargs)\n\nc:\\python38\\lib\\site-packages\\pymysql\\__init__.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000002C126CFE340>\nhost = 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com'\nuser = 'timing_read_only', password = 'db_only_hsyt21', database = 'timing'\nport = 3306, unix_socket = None, charset = 'utf8', sql_mode = None\nread_default_file = None\nconv = {<class 'bool'>: <function escape_bool at 0x000002C126BFA280>, <class 'int'>: <function escape_int at 0x000002C126BFA3...'>: <function escape_float at 0x000002C126BFA430>, <class 'str'>: <function escape_unicode at 0x000002C126BFA670>, ...}\nuse_unicode = True, client_flag = 3842575\ncursorclass = <class 'pymysql.cursors.Cursor'>, init_command = None\nconnect_timeout = 10, ssl = None, read_default_group = None, compress = None\nnamed_pipe = None, autocommit = False, db = 'timing', passwd = 'db_only_hsyt21'\nlocal_infile = False, max_allowed_packet = 16777216, defer_connect = False\nauth_plugin_map = None, read_timeout = None, write_timeout = None\nbind_address = None, binary_prefix = False, program_name = None\nserver_public_key = None\n\n    def __init__(self, host=None, user=None, password=\"\",\n                 database=None, port=0, unix_socket=None,\n                 charset='', sql_mode=None,\n                 read_default_file=None, conv=None, use_unicode=None,\n                 client_flag=0, cursorclass=Cursor, init_command=None,\n                 connect_timeout=10, ssl=None, read_default_group=None,\n                 compress=None, named_pipe=None,\n                 autocommit=False, db=None, passwd=None, local_infile=False,\n                 max_allowed_packet=16*1024*1024, defer_connect=False,\n                 auth_plugin_map=None, read_timeout=None, write_timeout=None,\n                 bind_address=None, binary_prefix=False, program_name=None,\n                 server_public_key=None):\n        if use_unicode is None and sys.version_info[0] > 2:\n            use_unicode = True\n    \n        if db is not None and database is None:\n            database = db\n        if passwd is not None and not password:\n            password = passwd\n    \n        if compress or named_pipe:\n            raise NotImplementedError(\"compress and named_pipe arguments are not supported\")\n    \n        self._local_infile = bool(local_infile)\n        if self._local_infile:\n            client_flag |= CLIENT.LOCAL_FILES\n    \n        if read_default_group and not read_default_file:\n            if sys.platform.startswith(\"win\"):\n                read_default_file = \"c:\\\\my.ini\"\n            else:\n                read_default_file = \"/etc/my.cnf\"\n    \n        if read_default_file:\n            if not read_default_group:\n                read_default_group = \"client\"\n    \n            cfg = Parser()\n            cfg.read(os.path.expanduser(read_default_file))\n    \n            def _config(key, arg):\n                if arg:\n                    return arg\n                try:\n                    return cfg.get(read_default_group, key)\n                except Exception:\n                    return arg\n    \n            user = _config(\"user\", user)\n            password = _config(\"password\", password)\n            host = _config(\"host\", host)\n            database = _config(\"database\", database)\n            unix_socket = _config(\"socket\", unix_socket)\n            port = int(_config(\"port\", port))\n            bind_address = _config(\"bind-address\", bind_address)\n            charset = _config(\"default-character-set\", charset)\n            if not ssl:\n                ssl = {}\n            if isinstance(ssl, dict):\n                for key in [\"ca\", \"capath\", \"cert\", \"key\", \"cipher\"]:\n                    value = _config(\"ssl-\" + key, ssl.get(key))\n                    if value:\n                        ssl[key] = value\n    \n        self.ssl = False\n        if ssl:\n            if not SSL_ENABLED:\n                raise NotImplementedError(\"ssl module not found\")\n            self.ssl = True\n            client_flag |= CLIENT.SSL\n            self.ctx = self._create_ssl_ctx(ssl)\n    \n        self.host = host or \"localhost\"\n        self.port = port or 3306\n        if type(self.port) is not int:\n            raise ValueError(\"port should be of type int\")\n        self.user = user or DEFAULT_USER\n        self.password = password or b\"\"\n        if isinstance(self.password, text_type):\n            self.password = self.password.encode('latin1')\n        self.db = database\n        self.unix_socket = unix_socket\n        self.bind_address = bind_address\n        if not (0 < connect_timeout <= 31536000):\n            raise ValueError(\"connect_timeout should be >0 and <=31536000\")\n        self.connect_timeout = connect_timeout or None\n        if read_timeout is not None and read_timeout <= 0:\n            raise ValueError(\"read_timeout should be > 0\")\n        self._read_timeout = read_timeout\n        if write_timeout is not None and write_timeout <= 0:\n            raise ValueError(\"write_timeout should be > 0\")\n        self._write_timeout = write_timeout\n        if charset:\n            self.charset = charset\n            self.use_unicode = True\n        else:\n            self.charset = DEFAULT_CHARSET\n            self.use_unicode = False\n    \n        if use_unicode is not None:\n            self.use_unicode = use_unicode\n    \n        self.encoding = charset_by_name(self.charset).encoding\n    \n        client_flag |= CLIENT.CAPABILITIES\n        if self.db:\n            client_flag |= CLIENT.CONNECT_WITH_DB\n    \n        self.client_flag = client_flag\n    \n        self.cursorclass = cursorclass\n    \n        self._result = None\n        self._affected_rows = 0\n        self.host_info = \"Not connected\"\n    \n        # specified autocommit mode. None means use server default.\n        self.autocommit_mode = autocommit\n    \n        if conv is None:\n            conv = converters.conversions\n    \n        # Need for MySQLdb compatibility.\n        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}\n        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}\n        self.sql_mode = sql_mode\n        self.init_command = init_command\n        self.max_allowed_packet = max_allowed_packet\n        self._auth_plugin_map = auth_plugin_map or {}\n        self._binary_prefix = binary_prefix\n        self.server_public_key = server_public_key\n    \n        self._connect_attrs = {\n            '_client_name': 'pymysql',\n            '_pid': str(os.getpid()),\n            '_client_version': VERSION_STRING,\n        }\n    \n        if program_name:\n            self._connect_attrs[\"program_name\"] = program_name\n    \n        if defer_connect:\n            self._sock = None\n        else:\n>           self.connect()\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000002C126CFE340>\nsock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG: print('connected using socket')\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                sock.settimeout(None)\n    \n            self._sock = sock\n            self._rfile = _makefile(sock, 'rb')\n            self._next_seq_id = 0\n    \n            self._get_server_information()\n            self._request_authentication()\n    \n            if self.sql_mode is not None:\n                c = self.cursor()\n                c.execute(\"SET sql_mode=%s\", (self.sql_mode,))\n    \n            if self.init_command is not None:\n                c = self.cursor()\n                c.execute(self.init_command)\n                c.close()\n                self.commit()\n    \n            if self.autocommit_mode is not None:\n                self.autocommit(self.autocommit_mode)\n        except BaseException as e:\n            self._rfile = None\n            if sock is not None:\n                try:\n                    sock.close()\n                except:  # noqa\n                    pass\n    \n            if isinstance(e, (OSError, IOError, socket.error)):\n                exc = err.OperationalError(\n                        2003,\n                        \"Can't connect to MySQL server on %r (%s)\" % (\n                            self.host, e))\n                # Keep original exception and traceback to investigate error.\n                exc.original_exception = e\n                exc.traceback = traceback.format_exc()\n                if DEBUG: print(exc.traceback)\n>               raise exc\nE               pymysql.err.OperationalError: (2003, \"Can't connect to MySQL server on 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com' ([Errno 11001] getaddrinfo failed)\")\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:619: OperationalError\n\nThe above exception was the direct cause of the following exception:\n\nself = <scripts.test_002_loginByCaptcha.Test_loginByCaptcha object at 0x000002C11AAB9C40>\n\n    def test_loginByCaptcha(self):\n        with allure.step('点击手机号登录'):\n            self.page.login().click_phone_login()\n        with allure.step('输入手机号'):\n            self.page.login_phone().input_phone(str(phone))\n        with allure.step('点击获取验证码按钮'):\n            self.page.login_phone().click_getCaptcha()\n            time.sleep(2)\n        with allure.step('正式服数据库拿验证码'):\n>           captcha = pd.read_sql('select captcha FROM t_captcha WHERE phone = \"' + str(phone) + '\" order by postTime desc',engine)\n\ntest_002_loginByCaptcha.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nc:\\python38\\lib\\site-packages\\pandas\\io\\sql.py:509: in read_sql\n    return pandas_sql.read_query(\nc:\\python38\\lib\\site-packages\\pandas\\io\\sql.py:1295: in read_query\n    result = self.execute(*args)\nc:\\python38\\lib\\site-packages\\pandas\\io\\sql.py:1161: in execute\n    return self.connectable.execution_options(no_parameters=True).execute(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2237: in execute\n    connection = self._contextual_connect(close_with_result=True)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2305: in _contextual_connect\n    self._wrap_pool_connect(self.pool.connect, None),\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2342: in _wrap_pool_connect\n    Connection._handle_dbapi_exception_noconnection(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:1584: in _handle_dbapi_exception_noconnection\n    util.raise_(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: in raise_\n    raise exception\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py:2339: in _wrap_pool_connect\n    return fn()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:364: in connect\n    return _ConnectionFairy._checkout(self)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:778: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:495: in checkout\n    rec = pool._do_get()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:140: in _do_get\n    self._dec_overflow()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: in __exit__\n    compat.raise_(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: in raise_\n    raise exception\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py:137: in _do_get\n    return self._create_connection()\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:309: in _create_connection\n    return _ConnectionRecord(self)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:440: in __init__\n    self.__connect(first_connect_check=True)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:661: in __connect\n    pool.logger.debug(\"Error on connect(): %s\", e)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:68: in __exit__\n    compat.raise_(\nc:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py:178: in raise_\n    raise exception\nc:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py:656: in __connect\n    connection = pool._invoke_creator(self)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\strategies.py:114: in connect\n    return dialect.connect(*cargs, **cparams)\nc:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\default.py:493: in connect\n    return self.dbapi.connect(*cargs, **cparams)\nc:\\python38\\lib\\site-packages\\pymysql\\__init__.py:94: in Connect\n    return Connection(*args, **kwargs)\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:327: in __init__\n    self.connect()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000002C126CFE340>\nsock = None\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG: print('connected using socket')\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                sock.settimeout(None)\n    \n            self._sock = sock\n            self._rfile = _makefile(sock, 'rb')\n            self._next_seq_id = 0\n    \n            self._get_server_information()\n            self._request_authentication()\n    \n            if self.sql_mode is not None:\n                c = self.cursor()\n                c.execute(\"SET sql_mode=%s\", (self.sql_mode,))\n    \n            if self.init_command is not None:\n                c = self.cursor()\n                c.execute(self.init_command)\n                c.close()\n                self.commit()\n    \n            if self.autocommit_mode is not None:\n                self.autocommit(self.autocommit_mode)\n        except BaseException as e:\n            self._rfile = None\n            if sock is not None:\n                try:\n                    sock.close()\n                except:  # noqa\n                    pass\n    \n            if isinstance(e, (OSError, IOError, socket.error)):\n                exc = err.OperationalError(\n                        2003,\n                        \"Can't connect to MySQL server on %r (%s)\" % (\n                            self.host, e))\n                # Keep original exception and traceback to investigate error.\n                exc.original_exception = e\n                exc.traceback = traceback.format_exc()\n                if DEBUG: print(exc.traceback)\n>               raise exc\nE               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, \"Can't connect to MySQL server on 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com' ([Errno 11001] getaddrinfo failed)\")\nE               (Background on this error at: http://sqlalche.me/e/13/e3q8)\n\nc:\\python38\\lib\\site-packages\\pymysql\\connections.py:619: OperationalError",
    "steps" : [ {
      "name" : "点击手机号登录",
      "time" : {
        "start" : 1606896150498,
        "stop" : 1606896157559,
        "duration" : 7061
      },
      "status" : "passed",
      "steps" : [ ],
      "attachments" : [ ],
      "parameters" : [ ],
      "stepsCount" : 0,
      "hasContent" : false,
      "attachmentsCount" : 0,
      "shouldDisplayMessage" : false
    }, {
      "name" : "输入手机号",
      "time" : {
        "start" : 1606896157559,
        "stop" : 1606896162554,
        "duration" : 4995
      },
      "status" : "passed",
      "steps" : [ ],
      "attachments" : [ ],
      "parameters" : [ ],
      "stepsCount" : 0,
      "hasContent" : false,
      "attachmentsCount" : 0,
      "shouldDisplayMessage" : false
    }, {
      "name" : "点击获取验证码按钮",
      "time" : {
        "start" : 1606896162554,
        "stop" : 1606896165307,
        "duration" : 2753
      },
      "status" : "passed",
      "steps" : [ ],
      "attachments" : [ ],
      "parameters" : [ ],
      "stepsCount" : 0,
      "hasContent" : false,
      "attachmentsCount" : 0,
      "shouldDisplayMessage" : false
    }, {
      "name" : "正式服数据库拿验证码",
      "time" : {
        "start" : 1606896165307,
        "stop" : 1606896187391,
        "duration" : 22084
      },
      "status" : "broken",
      "statusMessage" : "sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, \"Can't connect to MySQL server on 'rr-bp12u85w22spt5976do.mysql.rds.aliyuncs.com' ([Errno 11001] getaddrinfo failed)\")\n(Background on this error at: http://sqlalche.me/e/13/e3q8)\n",
      "statusTrace" : "  File \"D:\\Jenkins\\workspace\\Timing\\scripts\\test_002_loginByCaptcha.py\", line 38, in test_loginByCaptcha\n    captcha = pd.read_sql('select captcha FROM t_captcha WHERE phone = \"' + str(phone) + '\" order by postTime desc',engine)\n  File \"c:\\python38\\lib\\site-packages\\pandas\\io\\sql.py\", line 509, in read_sql\n    return pandas_sql.read_query(\n  File \"c:\\python38\\lib\\site-packages\\pandas\\io\\sql.py\", line 1295, in read_query\n    result = self.execute(*args)\n  File \"c:\\python38\\lib\\site-packages\\pandas\\io\\sql.py\", line 1161, in execute\n    return self.connectable.execution_options(no_parameters=True).execute(\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py\", line 2237, in execute\n    connection = self._contextual_connect(close_with_result=True)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py\", line 2305, in _contextual_connect\n    self._wrap_pool_connect(self.pool.connect, None),\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py\", line 2342, in _wrap_pool_connect\n    Connection._handle_dbapi_exception_noconnection(\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py\", line 1584, in _handle_dbapi_exception_noconnection\n    util.raise_(\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py\", line 178, in raise_\n    raise exception\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\base.py\", line 2339, in _wrap_pool_connect\n    return fn()\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py\", line 364, in connect\n    return _ConnectionFairy._checkout(self)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py\", line 778, in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py\", line 495, in checkout\n    rec = pool._do_get()\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py\", line 140, in _do_get\n    self._dec_overflow()\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py\", line 68, in __exit__\n    compat.raise_(\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py\", line 178, in raise_\n    raise exception\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\impl.py\", line 137, in _do_get\n    return self._create_connection()\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py\", line 309, in _create_connection\n    return _ConnectionRecord(self)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py\", line 440, in __init__\n    self.__connect(first_connect_check=True)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py\", line 661, in __connect\n    pool.logger.debug(\"Error on connect(): %s\", e)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\util\\langhelpers.py\", line 68, in __exit__\n    compat.raise_(\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\util\\compat.py\", line 178, in raise_\n    raise exception\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\pool\\base.py\", line 656, in __connect\n    connection = pool._invoke_creator(self)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\strategies.py\", line 114, in connect\n    return dialect.connect(*cargs, **cparams)\n  File \"c:\\python38\\lib\\site-packages\\sqlalchemy\\engine\\default.py\", line 493, in connect\n    return self.dbapi.connect(*cargs, **cparams)\n  File \"c:\\python38\\lib\\site-packages\\pymysql\\__init__.py\", line 94, in Connect\n    return Connection(*args, **kwargs)\n  File \"c:\\python38\\lib\\site-packages\\pymysql\\connections.py\", line 327, in __init__\n    self.connect()\n  File \"c:\\python38\\lib\\site-packages\\pymysql\\connections.py\", line 619, in connect\n    raise exc\n",
      "steps" : [ ],
      "attachments" : [ ],
      "parameters" : [ ],
      "stepsCount" : 0,
      "hasContent" : true,
      "attachmentsCount" : 0,
      "shouldDisplayMessage" : true
    } ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 4,
    "hasContent" : true,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : true
  },
  "afterStages" : [ ],
  "labels" : [ {
    "name" : "suite",
    "value" : "test_002_loginByCaptcha"
  }, {
    "name" : "subSuite",
    "value" : "Test_loginByCaptcha"
  }, {
    "name" : "host",
    "value" : "WINDOWS-49AO44L"
  }, {
    "name" : "thread",
    "value" : "4740-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "test_002_loginByCaptcha"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ ],
  "links" : [ ],
  "hidden" : true,
  "retry" : true,
  "extra" : {
    "categories" : [ ],
    "tags" : [ ]
  },
  "source" : "f744f579bd2f8262.json",
  "parameterValues" : [ ]
}